TITLE: Gavin Garzia, Section C, Chess

PROBLEM DESCRIPTION: I will be creating chess. It will be a two-player game with each
player entering their move and then letting the other player do the same. The computer 
will validate each move and make the users reenter moves until they enter a valid one. 
The computer will also notify the users when they are in check or checkmate. The UI 
will be in the command line, and will display the board, the pieces each player has 
captured. I will save the move list and final positon along with the result to a file.

PROGRAM DOCUMENTATION:
First the user must build my project using the included 
makefile, they they will run the “chess.exe” file. They will be prompted to enter 
player 1’s name, then player 2’s name. After this they will be prompted to enter 
their moves, starting with player 1, then 2. The moves should be formatted as the 
square the piece is moving from followed by a space, followed by the square the 
piece is moving to. I.e. to move the pawn on e2 to e4, they should enter “e2 e4”. 
If this is done incorrectly, they will be prompted to enter another move. The 
program should not need any modification, as chess has a set of rules that do not 
change. However, you may be interested in implementing other features such as a bot 
to play against. In that case, I would use the potential moves function in the Square 
class to show the bot where it can move. Then I would implement some kind of weighting 
system to tell the bot where it wants to put each type of piece for optimal 
effectiveness. Not much has changed since I proposed my project because, as mentioned 
earlier, chess has a set of unchanging rules and I had to adhere to them.

Additional Testing Notes: 
In the Game.cpp file there is a function titled test. I
chose to leave it in in case you need to test any other functions. Simply change 
game->run(); to game->test(); and edit the test function as needed. Additionally, 
in the Chessboard constructor, there is a variable named startingState. This contains 
a string of the starting state of the board. Upper case means white, lowercase means
black, / means new row, and it starts with the first row at “a1” and goes row by row 
until it ends at “h8”. Feel free to edit this to set up an easy checkmate or stalemate 
to test my code.  
"    K   /r      r/        /        /        /        /pppppppp/rnbqkbnr/" for example 
sets up an easy checkmate for black after 1. e1 to d1, h2 to h1. Leave the kings 
starting on e1 and e8 otherwise castling and checking break.

LIST DATA STRUCTURE: I used a 2d array of Squares to store all of the squares in 
the chessboard. I chose an array because it has constant access and I knew I would 
be accessing the elements often.


TESTS: 
1.	My program can handle any invalid input such as “1 2” because it checks to make 
sure that each position entered has a length of two. 
2.	It also checks to make sure that the 2 positions you entered are in side the 
chessboard “i0 i9” will print invalid position. 
3.	It checks that the from position corresponds to a piece matching the color of 
your pieces. In the starting position with white to move “e7 e5” will not be valid 
because e7 has a black pawn  on it even though moving the pawn on e7 to e5 is a valid 
move for black. 
4.	You are not allowed to make a move if it leaves the king in check. So there is 
a special case for that. Trying to make a move that puts your king in check will 
print out “cannot put king in check” and prompt the user to enter another move.
5.	Any other move input that cannot be processed will default to printing invalid 
input and prompting the user for a move


REFLECTIONS: I learned that sometimes it is better to take the time to fix a previous 
inefficiency rather than continue with it because it will not cause too much 
inconvenience in the future. I originally stored the position of a piece as a string 
with the first character the file, and the second the rank (e1, d6, h3). This 
resulted in me needing to convert the first character of the string into an integer 
representing which file the position was by subtracting 97 and casting to an integer 
( (int)(pos[0]-97) ), and convert the second character of the string to an integer 
representing the rank of the position by subtracting 49 and casting to an int 
( (int)(pos[1]-49) ). This, as you can tell from my code, makes my code cluttered 
and hard to follow. This represents a failure on my part to realize the scope of 
my project. When I had my first working prototype (full functionality, but no 
checking to see if moves were valid), converting the position to the two integers 
needed by the list was not cluttering my code because my code was much more simple. 
It was only when I started to add much more complex functionality to my code that 
the cluttering became a big deal. If I got the chance to do this project over I 
definitely would store the position as a list of two integers and convert it to 
a string when I needed to print it because this would allow for better readability 
and expansion because other programmers would be able to understand what is happening 
easier. In short, while my code works to the best of my knowledge, it is hard to read 
due to a mistake I thought would take longer to fix than to just deal with.

